import axios from 'axios';
import { API_BASE_URL } from '../config/api';
import { menuStorageService, MenuCacheEntry } from './MenuStorageService';

export interface MenuSection {
  id: string;
  name: string;
  title: string;
  description?: string;
  icon?: string;
  layout: 'grid' | 'list' | 'horizontal';
  is_active: boolean;
  meta_data: any;
  created_at: string;
  updated_at: string;
}

export interface MenuItem {
  id: string;
  title: string;
  description?: string;
  icon?: string;
  action_type: 'screen' | 'url' | 'action' | 'section';
  action_value?: string;
  parent_id?: string;
  section_id?: string;
  sort_order: number;
  is_active: boolean;
  is_premium: boolean;
  requires_auth: boolean;
  meta_data: any;
  created_at: string;
  updated_at: string;
}

export interface MenuData {
  sections: MenuSection[];
  items: MenuItem[];
  success: boolean;
}

export interface SupportedFormat {
  extensions: string[];
  mimeTypes: string[];
  maxFileSize?: number; // in bytes
}

export interface ProcessingContext {
  supported_formats: string[];
  processing_type?: string;
  enhancement_type?: string;
  generation_type?: string;
  content_type?: string;
}

export const SUPPORTED_FORMATS: Record<string, SupportedFormat> = {
  image: {
    extensions: ['jpg', 'jpeg', 'png', 'gif', 'webp'],
    mimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    maxFileSize: 50 * 1024 * 1024, // 50MB
  },
  video: {
    extensions: ['mp4', 'mov', 'avi', 'mkv', 'webm'],
    mimeTypes: ['video/mp4', 'video/quicktime', 'video/x-msvideo', 'video/x-matroska', 'video/webm'],
    maxFileSize: 500 * 1024 * 1024, // 500MB
  },
  animated: {
    extensions: ['gif', 'webp'],
    mimeTypes: ['image/gif', 'image/webp'],
    maxFileSize: 100 * 1024 * 1024, // 100MB
  }
};

class MenuService {
  private async getAuthHeaders() {
    // Add your authentication logic here
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };
    
    // Example: Add auth token if available
    // const token = await SecureStore.getItemAsync('auth_token');
    // if (token) {
    //   headers['Authorization'] = `Bearer ${token}`;
    // }
    
    return headers;
  }

  // Get screen-specific menu items
  getScreenItems(screenName: string, menuData: MenuData): MenuItem[] {
    const screenSection = menuData.sections.find(section => 
      section.meta_data?.screen === screenName
    );
    
    if (!screenSection) return [];
    
    return menuData.items
      .filter(item => item.section_id === screenSection.id && item.is_active)
      .sort((a, b) => a.sort_order - b.sort_order);
  }

  // Get supported formats for a menu item
  getSupportedFormatsForItem(item: MenuItem): string[] {
    return item.meta_data?.supported_formats || [];
  }

  // Validate file format for a menu item
  isFileSupportedForItem(fileName: string, item: MenuItem): boolean {
    const supportedFormats = this.getSupportedFormatsForItem(item);
    const fileExtension = fileName.split('.').pop()?.toLowerCase();
    return supportedFormats.includes(fileExtension || '');
  }

  // Get processing context for a menu item
  getProcessingContext(item: MenuItem): ProcessingContext {
    return {
      supported_formats: this.getSupportedFormatsForItem(item),
      processing_type: item.meta_data?.processing_type,
      enhancement_type: item.meta_data?.enhancement_type,
      generation_type: item.meta_data?.generation_type,
      content_type: item.meta_data?.content_type,
    };
  }

  // Get file type category (image, video, animated)
  getFileTypeCategory(fileName: string): string {
    const extension = fileName.split('.').pop()?.toLowerCase();
    
    if (SUPPORTED_FORMATS.video.extensions.includes(extension || '')) {
      return 'video';
    } else if (SUPPORTED_FORMATS.animated.extensions.includes(extension || '')) {
      return 'animated';
    } else {
      return 'image';
    }
  }

  // Validate file against size and format constraints
  validateFile(file: File, item: MenuItem): { valid: boolean; error?: string } {
    const supportedFormats = this.getSupportedFormatsForItem(item);
    const fileExtension = file.name.split('.').pop()?.toLowerCase();
    const fileType = this.getFileTypeCategory(file.name);
    
    // Check format support
    if (!supportedFormats.includes(fileExtension || '')) {
      return {
        valid: false,
        error: `File format .${fileExtension} is not supported for this feature`
      };
    }
    
    // Check file size
    const maxFileSize = SUPPORTED_FORMATS[fileType].maxFileSize;
    if (maxFileSize && file.size > maxFileSize) {
      const maxSizeMB = Math.round(maxFileSize / (1024 * 1024));
      return {
        valid: false,
        error: `File size exceeds ${maxSizeMB}MB limit for ${fileType} files`
      };
    }
    
    return { valid: true };
  }

  async getMenu(activeOnly: boolean = true): Promise<MenuData> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.get<MenuData>(
        `${API_BASE_URL}/api/menu?active_only=${activeOnly}`,
        { headers }
      );
      
      if (response.data.success) {
        return response.data;
      }
      
      throw new Error('Failed to fetch menu');
    } catch (error) {
      console.error('Error fetching menu:', error);
      throw error;
    }
  }

  // Versioned menu methods
  async getMenuConfig(
    environment: string = 'production',
    developmentMode: boolean = false,
    forceRefresh: boolean = false
  ): Promise<{ menuData: MenuData; version: string; fromCache: boolean }> {
    try {
      // Check development mode first
      if (developmentMode || await menuStorageService.getDevelopmentMode()) {
        const devResult = await this.getDevelopmentMenuConfig(environment);
        if (devResult) return devResult;
      }

      // Try to get from cache first
      if (!forceRefresh) {
        const cachedEntry = await menuStorageService.getCachedMenuData(environment);
        if (cachedEntry && !menuStorageService.isCacheExpired(cachedEntry.timestamp)) {
          return {
            menuData: cachedEntry.menuData,
            version: cachedEntry.version,
            fromCache: true,
          };
        }
      }

      // Fetch fresh config from server
      const freshConfig = await this.fetchMenuConfigFromServer(environment, developmentMode);
      return {
        menuData: freshConfig.menuData,
        version: freshConfig.version,
        fromCache: false,
      };
    } catch (error) {
      console.error('Error getting menu config:', error);
      
      // Fallback to cache if available
      const cachedEntry = await menuStorageService.getCachedMenuData(environment);
      if (cachedEntry) {
        console.log('Using cached menu data as fallback');
        return {
          menuData: cachedEntry.menuData,
          version: cachedEntry.version,
          fromCache: true,
        };
      }
      
      throw error;
    }
  }

  async getDevelopmentMenuConfig(environment: string = 'production'): Promise<{ menuData: MenuData; version: string; fromCache: boolean } | null> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.get(
        `${API_BASE_URL}/api/menu/config?environment=${environment}&development_mode=true`,
        { headers }
      );
      
      if (response.data && response.data.config) {
        const menuData: MenuData = {
          sections: response.data.config.sections || [],
          items: response.data.config.items || [],
          success: true,
        };
        
        return {
          menuData,
          version: response.data.version || 'development-latest',
          fromCache: false,
        };
      }
      
      return null;
    } catch (error) {
      console.error('Error getting development menu config:', error);
      return null;
    }
  }

  private async fetchMenuConfigFromServer(
    environment: string = 'production',
    developmentMode: boolean = false
  ): Promise<{ menuData: MenuData; version: string }> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.get(
        `${API_BASE_URL}/api/menu/config?environment=${environment}&development_mode=${developmentMode}`,
        { headers }
      );
      
      if (response.data && response.data.config) {
        const menuData: MenuData = {
          sections: response.data.config.sections || [],
          items: response.data.config.items || [],
          success: true,
        };
        
        // Cache the response
        const cacheEntry: MenuCacheEntry = {
          version: response.data.version || '1.0.0',
          menuData,
          timestamp: Date.now(),
          environment,
          isDevelopment: developmentMode,
        };
        
        await menuStorageService.cacheMenuData(cacheEntry);
        
        return {
          menuData,
          version: response.data.version || '1.0.0',
        };
      }
      
      throw new Error('Invalid menu config response');
    } catch (error) {
      console.error('Error fetching menu config from server:', error);
      throw error;
    }
  }

  async checkForUpdates(currentVersion: string, environment: string = 'production'): Promise<{ hasUpdate: boolean; latestVersion?: string; changelog?: string }> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.get(
        `${API_BASE_URL}/api/menu/config/check-version?current_version=${currentVersion}&environment=${environment}`,
        { headers }
      );
      
      if (response.data) {
        const hasUpdate = response.data.has_update || false;
        const latestVersion = response.data.latest_version;
        const changelog = response.data.changelog;
        
        // Update version info
        await menuStorageService.updateVersionInfo({
          hasUpdate,
          latestVersion,
        });
        
        return {
          hasUpdate,
          latestVersion,
          changelog,
        };
      }
      
      return { hasUpdate: false };
    } catch (error) {
      console.error('Error checking for updates:', error);
      return { hasUpdate: false };
    }
  }

  async updateMenuVersion(
    environment: string = 'production',
    versionIncrement: 'major' | 'minor' | 'patch' = 'patch',
    changelog?: string
  ): Promise<{ version: string; success: boolean }> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.post(
        `${API_BASE_URL}/api/menu/versions/auto-create`,
        {
          environment,
          version_increment: versionIncrement,
          changelog,
        },
        { headers }
      );
      
      if (response.data && response.data.version) {
        // Clear cache to force refresh
        await menuStorageService.clearOldCache();
        
        return {
          version: response.data.version,
          success: true,
        };
      }
      
      throw new Error('Failed to create version');
    } catch (error) {
      console.error('Error updating menu version:', error);
      return { version: '', success: false };
    }
  }

  async setDevelopmentMode(enabled: boolean): Promise<void> {
    try {
      await menuStorageService.setDevelopmentMode(enabled);
    } catch (error) {
      console.error('Error setting development mode:', error);
      throw error;
    }
  }

  async getDevelopmentMode(): Promise<boolean> {
    try {
      return await menuStorageService.getDevelopmentMode();
    } catch (error) {
      console.error('Error getting development mode:', error);
      return false;
    }
  }

  async getCurrentVersionInfo(): Promise<{
    currentVersion: string | null;
    environment: string;
    isDevelopment: boolean;
    hasUpdate: boolean;
    latestVersion?: string;
  }> {
    try {
      const versionInfo = await menuStorageService.getVersionInfo();
      const isDevelopment = await menuStorageService.getDevelopmentMode();
      
      if (versionInfo) {
        return {
          currentVersion: versionInfo.currentVersion,
          environment: versionInfo.environment,
          isDevelopment: isDevelopment || versionInfo.isDevelopment,
          hasUpdate: versionInfo.hasUpdate,
          latestVersion: versionInfo.latestVersion,
        };
      }
      
      return {
        currentVersion: null,
        environment: 'production',
        isDevelopment,
        hasUpdate: false,
      };
    } catch (error) {
      console.error('Error getting version info:', error);
      return {
        currentVersion: null,
        environment: 'production',
        isDevelopment: false,
        hasUpdate: false,
      };
    }
  }

  async getSections(activeOnly: boolean = true): Promise<MenuSection[]> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.get<MenuSection[]>(
        `${API_BASE_URL}/api/menu/sections?active_only=${activeOnly}`,
        { headers }
      );
      
      return response.data;
    } catch (error) {
      console.error('Error fetching menu sections:', error);
      throw error;
    }
  }

  async getItems(
    sectionId?: string,
    parentId?: string,
    activeOnly: boolean = true
  ): Promise<MenuItem[]> {
    try {
      const headers = await this.getAuthHeaders();
      const params = new URLSearchParams();
      
      if (sectionId) params.append('section_id', sectionId);
      if (parentId) params.append('parent_id', parentId);
      if (activeOnly) params.append('active_only', 'true');
      
      const response = await axios.get<MenuItem[]>(
        `${API_BASE_URL}/api/menu/items?${params.toString()}`,
        { headers }
      );
      
      return response.data;
    } catch (error) {
      console.error('Error fetching menu items:', error);
      throw error;
    }
  }

  async createSection(sectionData: {
    name: string;
    title: string;
    description?: string;
    icon?: string;
    layout?: 'grid' | 'list' | 'horizontal';
    sort_order?: number;
    is_active?: boolean;
    metadata?: any;
  }): Promise<MenuSection> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.post<MenuSection>(
        `${API_BASE_URL}/api/menu/sections`,
        sectionData,
        { headers }
      );
      
      return response.data;
    } catch (error) {
      console.error('Error creating menu section:', error);
      throw error;
    }
  }

  async updateSection(
    sectionId: string,
    updateData: Partial<{
      name: string;
      title: string;
      description?: string;
      icon?: string;
      layout: 'grid' | 'list' | 'horizontal';
      sort_order: number;
      is_active: boolean;
      meta_data: any;
    }>
  ): Promise<MenuSection> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.put<MenuSection>(
        `${API_BASE_URL}/api/menu/sections/${sectionId}`,
        updateData,
        { headers }
      );
      
      return response.data;
    } catch (error) {
      console.error('Error updating menu section:', error);
      throw error;
    }
  }

  async deleteSection(sectionId: string): Promise<void> {
    try {
      const headers = await this.getAuthHeaders();
      await axios.delete(
        `${API_BASE_URL}/api/menu/sections/${sectionId}`,
        { headers }
      );
    } catch (error) {
      console.error('Error deleting menu section:', error);
      throw error;
    }
  }

  async createItem(itemData: {
    title: string;
    description?: string;
    icon?: string;
    action_type: 'screen' | 'url' | 'action' | 'section';
    action_value?: string;
    parent_id?: string;
    section_id?: string;
    sort_order?: number;
    is_active?: boolean;
    is_premium?: boolean;
    requires_auth?: boolean;
    metadata?: any;
  }): Promise<MenuItem> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.post<MenuItem>(
        `${API_BASE_URL}/api/menu/items`,
        itemData,
        { headers }
      );
      
      return response.data;
    } catch (error) {
      console.error('Error creating menu item:', error);
      throw error;
    }
  }

  async updateItem(
    itemId: string,
    updateData: Partial<{
      title: string;
      description?: string;
      icon?: string;
      action_type: 'screen' | 'url' | 'action' | 'section';
      action_value?: string;
      parent_id?: string;
      section_id?: string;
      sort_order: number;
      is_active: boolean;
      is_premium: boolean;
      requires_auth: boolean;
      meta_data: any;
    }>
  ): Promise<MenuItem> {
    try {
      const headers = await this.getAuthHeaders();
      const response = await axios.put<MenuItem>(
        `${API_BASE_URL}/api/menu/items/${itemId}`,
        updateData,
        { headers }
      );
      
      return response.data;
    } catch (error) {
      console.error('Error updating menu item:', error);
      throw error;
    }
  }

  async deleteItem(itemId: string): Promise<void> {
    try {
      const headers = await this.getAuthHeaders();
      await axios.delete(
        `${API_BASE_URL}/api/menu/items/${itemId}`,
        { headers }
      );
    } catch (error) {
      console.error('Error deleting menu item:', error);
      throw error;
    }
  }

  async reorderSections(sectionOrders: Array<{ section_id: string; sort_order: number }>): Promise<void> {
    try {
      const headers = await this.getAuthHeaders();
      await axios.post(
        `${API_BASE_URL}/api/menu/sections/reorder`,
        sectionOrders,
        { headers }
      );
    } catch (error) {
      console.error('Error reordering menu sections:', error);
      throw error;
    }
  }

  async reorderItems(itemOrders: Array<{ item_id: string; sort_order: number }>): Promise<void> {
    try {
      const headers = await this.getAuthHeaders();
      await axios.post(
        `${API_BASE_URL}/api/menu/items/reorder`,
        itemOrders,
        { headers }
      );
    } catch (error) {
      console.error('Error reordering menu items:', error);
      throw error;
    }
  }
}

export const menuService = new MenuService();
export default menuService;